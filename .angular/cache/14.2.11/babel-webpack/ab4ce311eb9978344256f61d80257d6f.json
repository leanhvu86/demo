{"ast":null,"code":"import { EventEmitter, Output, Injectable, InjectionToken, Inject, Optional, NgZone, Component, ElementRef, ViewEncapsulation, Directive, ViewChild, ViewContainerRef, Input, NgModule } from '@angular/core';\nimport { Observable, ReplaySubject, Subject } from 'rxjs';\nimport { debounceTime, tap, first } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * return json string from json-like string\n * @param {?} str\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"*\"];\nconst _c1 = [\"template\"];\n\nfunction jsonize(str) {\n  try {\n    // if parsable already, return as it is\n    JSON.parse(str);\n    return str;\n  } catch (\n  /** @type {?} */\n  e) {\n    // if not parsable, change little\n    return str.replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n    // wrap keys without double quote\n    function (_, $1) {\n      return '\"' + $1 + '\":';\n    }).replace(/'([^']+)'/g, // replacing single quote to double quote\n    // replacing single quote to double quote\n    function (_, $1) {\n      return '\"' + $1 + '\"';\n    });\n  }\n}\n/**\n * Returns string to an object by using JSON.parse()\n * @param {?} input\n * @return {?}\n */\n\n\nfunction getJSON(input) {\n  if (typeof input === 'string') {\n    const\n    /** @type {?} */\n    re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n\n    if (input.match(re)) {\n      input = '[' + input + ']';\n    }\n\n    return JSON.parse(jsonize(input));\n  } else {\n    return input;\n  }\n}\n/**\n * json type definition\n * @record\n */\n\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n * @param {?} str\n * @return {?}\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n    return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n  }).replace(/\\s+/g, '');\n}\n/**\n * @return {?}\n */\n\n\nfunction isMapsApiLoaded() {\n  return typeof google === 'object' && typeof google.maps === 'object';\n}\n/**\n * @param {?} component\n * @param {?} libName\n * @return {?}\n */\n\n\nfunction missingLibraryError(component, libName) {\n  return Error(`${component}: library '${libName}' is missing, please ensure to include it in a 'libraries' parameter.\n    Example:\n      NguiMapModule.forRoot({\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=${libName}'\n      })\n  `);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @abstract\n */\n\n\nlet BaseMapDirective = /*#__PURE__*/(() => {\n  class BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} mapObjectName\n     * @param {?} inputs\n     * @param {?} outputs\n     */\n    constructor(nguiMapComponent, mapObjectName, inputs, outputs) {\n      this.nguiMapComponent = nguiMapComponent;\n      this.mapObjectName = mapObjectName;\n      this.inputs = inputs;\n      this.outputs = outputs; // this should be redefined on each childr directive\n\n      this.initialized$ = new EventEmitter();\n      this._subscriptions = [];\n      this.nguiMap = this.nguiMapComponent['nguiMap'];\n      this.optionBuilder = this.nguiMapComponent['optionBuilder']; // all outputs must be initialized\n\n      this.outputs.forEach(output => this[output] = new EventEmitter());\n      this.mapObjectName = mapObjectName;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.nguiMapComponent.mapIdledOnce) {\n        // map is ready already\n        this.initialize();\n      } else {\n        this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this); // will be set after geocoded\n\n      typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n      typeof this.objectOptions.center === 'string' && delete this.objectOptions.center; // noinspection TypeScriptUnresolvedFunction\n\n      if (this.libraryName) {\n        if (!google.maps[this.libraryName]) {\n          throw missingLibraryError(this.mapObjectName, this.libraryName);\n        }\n\n        this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n      } else {\n        this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n      }\n\n      this.mapObject.setMap(this.nguiMapComponent.map);\n      this.mapObject['mapObjectName'] = this.mapObjectName;\n      this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n      this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n      this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n      this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.nguiMap.updateGoogleObject(this.mapObject, changes);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._subscriptions.map(subscription => subscription.unsubscribe());\n\n      this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n\n      if (this.mapObject) {\n        this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n      }\n    }\n\n  }\n\n  BaseMapDirective.ɵfac = function BaseMapDirective_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  BaseMapDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseMapDirective,\n    outputs: {\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return BaseMapDirective;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\nlet OptionBuilder = /*#__PURE__*/(() => {\n  class OptionBuilder {\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n    googlizeAllInputs(definedInputs, userInputs) {\n      let\n      /** @type {?} */\n      options = {}; // if options given from user, only take options and ignore other inputs\n\n      if (userInputs.options) {\n        options = userInputs.options;\n\n        if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n          console.error('when \"options\" are used, other options are ignored');\n        }\n      } else {\n        // if options not given, process all user inputs\n        definedInputs.forEach(input => {\n          if (userInputs[input] !== undefined) {\n            options[input] = this.googlize(userInputs[input], {\n              key: input\n            });\n          }\n        });\n      }\n\n      return options;\n    }\n    /**\n     * @param {?} inputs\n     * @param {?=} options\n     * @return {?}\n     */\n\n\n    googlizeMultiple(inputs, options) {\n      options = options || {};\n\n      for (let\n      /** @type {?} */\n      key in inputs) {\n        let\n        /** @type {?} */\n        val = inputs[key]; // (non-strings are fully converted)\n\n        if (typeof val !== 'string') {\n          options[key] = val;\n        } else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n          options[key] = this.googlize(val, {\n            key: key\n          });\n        }\n      } // for(var key in attrs)\n\n\n      return options;\n    }\n    /**\n     * @param {?} input\n     * @param {?=} options\n     * @return {?}\n     */\n\n\n    googlize(input, options) {\n      options = options || {};\n      let\n      /** @type {?} */\n      output = input;\n\n      if (typeof input === 'string') {\n        // convert string to a google object\n        if (input === 'false') {\n          output = false;\n        } else if (input === '0') {\n          output = 0;\n        } else {\n          output = // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n          this.getJSONParsed(input, options)\n          /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n          || this.getAnyMapObject(input)\n          /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n          || this.getAnyMapConstant(input, options)\n          /*  2016-06-20 -> new Date('2016-06-20') */\n          || this.getDateObject(input) || input;\n        }\n      }\n\n      if (options['key']) {\n        let\n        /** @type {?} */\n        key =\n        /** @type {?} */\n        options['key'];\n\n        if (output instanceof Array) {\n          // e.g., [1, 2]\n          if (key === 'bounds') {\n            output = new google.maps.LatLngBounds(output[0], output[1]);\n          } else if (key === 'icons') {\n            output = this.getMapIcons(output);\n          } else if (key === 'position' || key.match(/^geoFallback/)) {\n            output = this.getLatLng(output);\n          }\n        } else if (output instanceof Object) {\n          if (key === 'icon') {\n            output = this.getMarkerIcon(output);\n          } else if (key.match(/ControlOptions$/)) {\n            output = this.getMapControlOption(output);\n          }\n        }\n      } // delete keys only for processing, not used by google\n\n\n      delete output['doNotConverStringToNumber'];\n      delete output['key'];\n      return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    getLatLng(input) {\n      let\n      /** @type {?} */\n      output;\n\n      if (input[0].constructor === Array) {\n        // [[1,2],[3,4]]\n        output =\n        /** @type {?} */\n        input.map(el => new google.maps.LatLng(el[0], el[1]));\n      } else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n        output = new google.maps.LatLng(input[0], input[1]);\n      }\n\n      return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    getJSONParsed(input, options) {\n      let\n      /** @type {?} */\n      output;\n\n      try {\n        output = getJSON(input);\n\n        if (output instanceof Array) {\n          // [{a:1}] : not lat/lng ones\n          if (output[0].constructor !== Object) {\n            // [[1,2],[3,4]] or [1,2]\n            output = this.getLatLng(output);\n          }\n        } else if (output === Object(output)) {\n          // check for nested hashes and convert to Google API options\n          let\n          /** @type {?} */\n          newOptions = options;\n          newOptions['doNotConverStringToNumber'] = true;\n          output = this.googlizeMultiple(output, newOptions);\n        }\n      } catch (\n      /** @type {?} */\n      e) {}\n\n      return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    getAnyMapObject(input) {\n      let\n      /** @type {?} */\n      output;\n\n      if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n        try {\n          output = Function(`return new google.maps.${input};`)();\n        } catch (\n        /** @type {?} */\n        e) {}\n      }\n\n      return output;\n    }\n    /**\n     * @param {?} input\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    getAnyMapConstant(input, options) {\n      let\n      /** @type {?} */\n      output;\n\n      if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n        // e.g. MapTypeID.HYBRID\n        try {\n          let\n          /** @type {?} */\n          matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n          output = google.maps[matches[1]][matches[2]];\n        } catch (\n        /** @type {?} */\n        e) {}\n      } else if (input.match(/^[A-Z]+$/)) {\n        // e.g. HYBRID\n        try {\n          let\n          /** @type {?} */\n          capitalizedKey =\n          /** @type {?} */\n          options['key'].charAt(0).toUpperCase() +\n          /** @type {?} */\n          options['key'].slice(1);\n          output = google.maps[capitalizedKey][input];\n        } catch (\n        /** @type {?} */\n        e) {}\n      }\n\n      return output;\n    }\n    /**\n     * streetviewControl, panControl, etc, not a general control\n     * @param {?} controlOptions\n     * @return {?}\n     */\n\n\n    getMapControlOption(controlOptions) {\n      let\n      /** @type {?} */\n      newControlOptions = controlOptions;\n\n      for (let\n      /** @type {?} */\n      key in newControlOptions) {\n        // assign the right values\n        if (newControlOptions[key]) {\n          let\n          /** @type {?} */\n          value = newControlOptions[key];\n\n          if (typeof value === 'string') {\n            value =\n            /** @type {?} */\n            value.toUpperCase();\n          } else if (key === 'mapTypeIds') {\n            value =\n            /** @type {?} */\n            value.map(function (str) {\n              if (str.match(/^[A-Z]+$/)) {\n                // if constant\n                return google.maps.MapTypeId[str.toUpperCase()];\n              } else {\n                // else, custom map-type\n                return str;\n              }\n            });\n          }\n\n          if (key === 'style') {\n            let\n            /** @type {?} */\n            objName = key.replace(/Options$/, '') + 'Style';\n            newControlOptions[key] = google.maps[objName][\n            /** @type {?} */\n            value];\n          } else if (key === 'position') {\n            newControlOptions[key] = google.maps.ControlPosition[\n            /** @type {?} */\n            value];\n          } else {\n            newControlOptions[key] = value;\n          }\n        }\n      }\n\n      return newControlOptions;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    getDateObject(input) {\n      let\n      /** @type {?} */\n      output;\n\n      if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n        try {\n          output = new Date(input);\n        } catch (\n        /** @type {?} */\n        e) {}\n      }\n\n      return output;\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    getMapIcons(input) {\n      return input.map(el => {\n        if (el.icon.path.match(/^[A-Z_]+$/)) {\n          el.icon.path = google.maps.SymbolPath[el.icon.path];\n        }\n\n        return el;\n      });\n    }\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    getMarkerIcon(input) {\n      let\n      /** @type {?} */\n      output = input;\n\n      if (('' + output.path).match(/^[A-Z_]+$/)) {\n        output.path = google.maps.SymbolPath[output.path];\n      }\n\n      for (let\n      /** @type {?} */\n      key in output) {\n        let\n        /** @type {?} */\n        arr = output[key];\n\n        if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n          output[key] = new google.maps.Point(arr[0], arr[1]);\n        } else if (key === 'size' || key === 'scaledSize') {\n          output[key] = new google.maps.Size(arr[0], arr[1]);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * @param {?} definedInputs\n     * @param {?} userInputs\n     * @return {?}\n     */\n\n\n    onlyOptionsGiven(definedInputs, userInputs) {\n      for (let\n      /** @type {?} */\n      i = 0; i < definedInputs.length; i++) {\n        let\n        /** @type {?} */\n        input = definedInputs[i];\n\n        if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n  }\n\n  OptionBuilder.ɵfac = function OptionBuilder_Factory(t) {\n    return new (t || OptionBuilder)();\n  };\n\n  OptionBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: OptionBuilder,\n    factory: OptionBuilder.ɵfac\n  });\n  return OptionBuilder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *  service for navigator.geolocation methods\n */\n\n\nlet NavigatorGeolocation = /*#__PURE__*/(() => {\n  class NavigatorGeolocation {\n    /**\n     * @param {?=} geoLocationOptions\n     * @return {?}\n     */\n    getCurrentPosition(geoLocationOptions) {\n      geoLocationOptions = geoLocationOptions || {\n        timeout: 5000\n      };\n      return new Observable(responseObserver => {\n        if (navigator.geolocation) {\n          navigator.geolocation.getCurrentPosition(position => {\n            responseObserver.next(position);\n            responseObserver.complete();\n          }, evt => responseObserver.error(evt), geoLocationOptions);\n        } else {\n          responseObserver.error('Browser Geolocation service failed.');\n        }\n      });\n    }\n\n  }\n\n  NavigatorGeolocation.ɵfac = function NavigatorGeolocation_Factory(t) {\n    return new (t || NavigatorGeolocation)();\n  };\n\n  NavigatorGeolocation.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NavigatorGeolocation,\n    factory: NavigatorGeolocation.ɵfac\n  });\n  return NavigatorGeolocation;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst NG_MAP_CONFIG_TOKEN = new InjectionToken('NG_MAP_CONFIG_TOKEN');\n/**\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @abstract\n */\n\nlet NgMapApiLoader = /*#__PURE__*/(() => {\n  class NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n      this.config = config;\n      this.api$ = new ReplaySubject(1);\n      this.config = this.config || {\n        apiUrl: 'https://maps.google.com/maps/api/js'\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.api$.complete();\n    }\n\n  }\n\n  NgMapApiLoader.ɵfac = function NgMapApiLoader_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  NgMapApiLoader.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgMapApiLoader\n  });\n  return NgMapApiLoader;\n})();\nlet NgMapAsyncCallbackApiLoader = /*#__PURE__*/(() => {\n  class NgMapAsyncCallbackApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} zone\n     * @param {?} config\n     */\n    constructor(zone, config) {\n      super(config);\n      this.zone = zone;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    load() {\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      if (isMapsApiLoaded()) {\n        this.api$.next(google.maps);\n      } else if (!document.querySelector('#ngui-map-api')) {\n        /** @type {?} */\n        window['nguiMapRef'] =\n        /** @type {?} */\n        window['nguiMapRef'] || [];\n\n        /** @type {?} */\n        window['nguiMapRef'].push({\n          zone: this.zone,\n          componentFn: () => this.api$.next(google.maps)\n        });\n        this.addGoogleMapsApi();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    addGoogleMapsApi() {\n      /** @type {?} */\n      window['initNguiMap'] =\n      /** @type {?} */\n      window['initNguiMap'] || function () {\n        /** @type {?} */\n        window['nguiMapRef'].forEach(nguiMapRef => {\n          nguiMapRef.zone.run(function () {\n            nguiMapRef.componentFn();\n          });\n        });\n\n        /** @type {?} */\n        window['nguiMapRef'].splice(0,\n        /** @type {?} */\n        window['nguiMapRef'].length);\n      };\n\n      let\n      /** @type {?} */\n      script = document.createElement('script');\n      script.id = 'ngui-map-api'; // script.src = \"https://maps.google.com/maps/api/js?callback=initNguiMap\";\n\n      let\n      /** @type {?} */\n      apiUrl = this.config.apiUrl;\n      apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n      script.src = apiUrl + 'callback=initNguiMap';\n      document.querySelector('body').appendChild(script);\n    }\n\n  }\n\n  NgMapAsyncCallbackApiLoader.ɵfac = function NgMapAsyncCallbackApiLoader_Factory(t) {\n    return new (t || NgMapAsyncCallbackApiLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8));\n  };\n\n  NgMapAsyncCallbackApiLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgMapAsyncCallbackApiLoader,\n    factory: NgMapAsyncCallbackApiLoader.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgMapAsyncCallbackApiLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgMapAsyncApiLoader = /*#__PURE__*/(() => {\n  class NgMapAsyncApiLoader extends NgMapApiLoader {\n    /**\n     * @param {?} config\n     */\n    constructor(config) {\n      super(config);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    load() {\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      if (isMapsApiLoaded()) {\n        this.api$.next(google.maps);\n      } else if (!document.querySelector('#ngui-map-api')) {\n        let\n        /** @type {?} */\n        script = document.createElement('script');\n        script.id = 'ngui-map-api';\n        script.async = true;\n\n        script.onload = () => this.api$.next(google.maps);\n\n        script.src = this.config.apiUrl;\n        document.querySelector('body').appendChild(script);\n      }\n    }\n\n  }\n\n  NgMapAsyncApiLoader.ɵfac = function NgMapAsyncApiLoader_Factory(t) {\n    return new (t || NgMapAsyncApiLoader)(ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8));\n  };\n\n  NgMapAsyncApiLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgMapAsyncApiLoader,\n    factory: NgMapAsyncApiLoader.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgMapAsyncApiLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\n\n\nlet GeoCoder = /*#__PURE__*/(() => {\n  class GeoCoder {\n    /**\n     * @param {?} apiLoader\n     */\n    constructor(apiLoader) {\n      this.apiLoader = apiLoader;\n      this.apiLoaderSubs = [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    geocode(options) {\n      return new Observable(responseObserver => {\n        this.apiLoaderSubs.push(this.apiLoader.api$.subscribe(() => this.requestGeocode(options, responseObserver)));\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.apiLoaderSubs.map(sub => sub.unsubscribe());\n    }\n    /**\n     * @param {?} options\n     * @param {?} observer\n     * @return {?}\n     */\n\n\n    requestGeocode(options, observer) {\n      const\n      /** @type {?} */\n      geocoder = new google.maps.Geocoder();\n      geocoder.geocode(options, function (results, status) {\n        if (status === google.maps.GeocoderStatus.OK) {\n          observer.next(results);\n          observer.complete();\n        } else {\n          observer.error(results);\n        }\n      });\n    }\n\n  }\n\n  GeoCoder.ɵfac = function GeoCoder_Factory(t) {\n    return new (t || GeoCoder)(ɵngcc0.ɵɵinject(NgMapApiLoader));\n  };\n\n  GeoCoder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: GeoCoder,\n    factory: GeoCoder.ɵfac\n  });\n  /** @nocollapse */\n\n  return GeoCoder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * collection of map instance-related properties and methods\n */\n\n\nlet NguiMap = /*#__PURE__*/(() => {\n  class NguiMap {\n    /**\n     * @param {?} geoCoder\n     * @param {?} optionBuilder\n     * @param {?} zone\n     */\n    constructor(geoCoder, optionBuilder, zone) {\n      this.geoCoder = geoCoder;\n      this.optionBuilder = optionBuilder;\n      this.zone = zone;\n\n      this.updateGoogleObject = (object, changes) => {\n        let\n        /** @type {?} */\n        val,\n        /** @type {?} */\n        currentValue,\n        /** @type {?} */\n        setMethodName;\n\n        if (object) {\n          for (let\n          /** @type {?} */\n          key in changes) {\n            setMethodName = `set${key.replace(/^[a-z]/, x => x.toUpperCase())}`;\n            currentValue = changes[key].currentValue;\n\n            if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n              // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n              (setMethodName => {\n                this.geoCoder.geocode({\n                  address: currentValue\n                }).subscribe(results => {\n                  if (typeof object[setMethodName] === 'function') {\n                    object[setMethodName](results[0].geometry.location);\n                  } else {\n                    console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                  }\n                });\n              })(setMethodName);\n            } else {\n              val = this.optionBuilder.googlize(currentValue);\n\n              if (typeof object[setMethodName] === 'function') {\n                object[setMethodName](val);\n              } else {\n                console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n              }\n            }\n          }\n        }\n      };\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n\n\n    setObjectEvents(definedEvents, thisObj, prefix) {\n      definedEvents.forEach(definedEvent => {\n        const\n        /** @type {?} */\n        eventName = this.getEventName(definedEvent),\n\n        /** @type {?} */\n        zone = this.zone;\n        zone.runOutsideAngular(() => {\n          thisObj[prefix].addListener(eventName, function (event) {\n            let\n            /** @type {?} */\n            param = event ? event : {};\n            param.target = this;\n            zone.run(() => thisObj[definedEvent].emit(param));\n          });\n        });\n      });\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n\n\n    clearObjectEvents(definedEvents, thisObj, prefix) {\n      definedEvents.forEach(definedEvent => {\n        const\n        /** @type {?} */\n        eventName = this.getEventName(definedEvent);\n        this.zone.runOutsideAngular(() => {\n          if (thisObj[prefix]) {\n            google.maps.event.clearListeners(thisObj[prefix], eventName);\n          }\n        });\n      });\n\n      if (thisObj[prefix]) {\n        if (thisObj[prefix].setMap) {\n          thisObj[prefix].setMap(null);\n        }\n\n        delete thisObj[prefix].nguiMapComponent;\n        delete thisObj[prefix];\n      }\n    }\n    /**\n     * @param {?} definedEvent\n     * @return {?}\n     */\n\n\n    getEventName(definedEvent) {\n      return definedEvent.replace(/([A-Z])/g, $1 => `_${$1.toLowerCase()}`) // positionChanged -> position_changed\n      .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n    }\n\n  }\n\n  NguiMap.ɵfac = function NguiMap_Factory(t) {\n    return new (t || NguiMap)(ɵngcc0.ɵɵinject(GeoCoder), ɵngcc0.ɵɵinject(OptionBuilder), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  NguiMap.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NguiMap,\n    factory: NguiMap.ɵfac\n  });\n  /** @nocollapse */\n\n  return NguiMap;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS = ['backgroundColor', 'center', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'heading', 'keyboardShortcuts', 'mapMaker', 'mapTypeControl', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'overviewMapControl', 'panControl', 'panControlOptions', 'rotateControl', 'scaleControl', 'scrollwheel', 'streetView', 'styles', 'tilt', 'zoom', 'streetViewControl', 'zoomControl', 'zoomControlOptions', 'mapTypeControlOptions', 'overviewMapControlOptions', 'rotateControlOptions', 'scaleControlOptions', 'streetViewControlOptions', 'fullscreenControl', 'fullscreenControlOptions', 'options', 'geoFallbackCenter'];\nconst OUTPUTS = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tile_changed', 'zoom_changed', 'mapClick', 'mapMouseover', 'mapMouseout', 'mapMousemove', 'mapDrag', 'mapDragend', 'mapDragstart'];\nlet NguiMapComponent = /*#__PURE__*/(() => {\n  class NguiMapComponent {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} geolocation\n     * @param {?} geoCoder\n     * @param {?} nguiMap\n     * @param {?} apiLoader\n     * @param {?} zone\n     */\n    constructor(optionBuilder, elementRef, geolocation, geoCoder, nguiMap, apiLoader, zone) {\n      this.optionBuilder = optionBuilder;\n      this.elementRef = elementRef;\n      this.geolocation = geolocation;\n      this.geoCoder = geoCoder;\n      this.nguiMap = nguiMap;\n      this.apiLoader = apiLoader;\n      this.zone = zone;\n      this.mapReady$ = new EventEmitter();\n      this.mapOptions = {};\n      this.inputChanges$ = new Subject();\n      this.infoWindows = {};\n      this.mapIdledOnce = false;\n      this.initializeMapAfterDisplayed = false;\n      apiLoader.load(); // all outputs needs to be initialized,\n      // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\n      OUTPUTS.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.apiLoaderSub = this.apiLoader.api$.pipe(first()).subscribe(() => this.initializeMap());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewChecked() {\n      if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n        this.initializeMap();\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initializeMap() {\n      this.el = this.elementRef.nativeElement.querySelector('.google-map');\n\n      if (this.el && this.el.offsetWidth === 0) {\n        this.initializeMapAfterDisplayed = true;\n        return;\n      }\n\n      this.initializeMapAfterDisplayed = false;\n      this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n      this.mapOptions.zoom = this.mapOptions.zoom || 15;\n      typeof this.mapOptions.center === 'string' && delete this.mapOptions.center;\n      this.zone.runOutsideAngular(() => {\n        this.map = new google.maps.Map(this.el, this.mapOptions);\n        this.map['mapObjectName'] = 'NguiMapComponent';\n\n        if (!this.mapOptions.center) {\n          // if center is not given as lat/lng\n          this.setCenter();\n        } // set google events listeners and emits to this outputs listeners\n\n\n        this.nguiMap.setObjectEvents(OUTPUTS, this, 'map');\n        this.map.addListener('idle', () => {\n          if (!this.mapIdledOnce) {\n            this.mapIdledOnce = true;\n            setTimeout(() => {\n              // Why????, subsribe and emit must not be in the same cycle???\n              this.mapReady$.emit(this.map);\n            });\n          }\n        }); // update map when input changes\n\n        this.inputChanges$.pipe(debounceTime(1000), tap(changes => this.nguiMap.updateGoogleObject(this.map, changes))).subscribe();\n\n        if (typeof window !== 'undefined' &&\n        /** @type {?} */\n        window['nguiMapRef']) {\n          // expose map object for test and debugging on (<any>window)\n\n          /** @type {?} */\n          window['nguiMapRef'].map = this.map;\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setCenter() {\n      if (!this['center']) {\n        // center is not from user. Thus, we set the current location\n        this.geolocation.getCurrentPosition().subscribe(position => {\n          let\n          /** @type {?} */\n          latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n          this.map.setCenter(latLng);\n        }, error => {\n          console.error('ngui-map: Error finding the current position');\n          this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        });\n      } else if (typeof this['center'] === 'string') {\n        this.geoCoder.geocode({\n          address: this['center']\n        }).subscribe(results => {\n          this.map.setCenter(results[0].geometry.location);\n        }, error => {\n          this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        });\n      }\n    }\n    /**\n     * @param {?} id\n     * @param {?} anchor\n     * @return {?}\n     */\n\n\n    openInfoWindow(id, anchor) {\n      this.infoWindows[id].open(anchor);\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n\n\n    closeInfoWindow(id) {\n      // if infoWindow for id exists, close the infoWindow\n      if (this.infoWindows[id]) this.infoWindows[id].close();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.inputChanges$.complete();\n\n      if (this.el && !this.initializeMapAfterDisplayed) {\n        this.nguiMap.clearObjectEvents(OUTPUTS, this, 'map');\n      }\n\n      if (this.apiLoaderSub) {\n        this.apiLoaderSub.unsubscribe();\n      }\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n\n\n    addToMapObjectGroup(mapObjectName, mapObject) {\n      let\n      /** @type {?} */\n      groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n      this.map[groupName] = this.map[groupName] || [];\n      this.map[groupName].push(mapObject);\n    }\n    /**\n     * @param {?} mapObjectName\n     * @param {?} mapObject\n     * @return {?}\n     */\n\n\n    removeFromMapObjectGroup(mapObjectName, mapObject) {\n      let\n      /** @type {?} */\n      groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n      if (this.map && this.map[groupName]) {\n        let\n        /** @type {?} */\n        index = this.map[groupName].indexOf(mapObject);\n        index > -1 && this.map[groupName].splice(index, 1);\n      }\n    }\n\n  }\n\n  NguiMapComponent.ɵfac = function NguiMapComponent_Factory(t) {\n    return new (t || NguiMapComponent)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation), ɵngcc0.ɵɵdirectiveInject(GeoCoder), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  NguiMapComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NguiMapComponent,\n    selectors: [[\"ngui-map\"]],\n    inputs: {\n      backgroundColor: \"backgroundColor\",\n      center: \"center\",\n      disableDefaultUI: \"disableDefaultUI\",\n      disableDoubleClickZoom: \"disableDoubleClickZoom\",\n      draggable: \"draggable\",\n      draggableCursor: \"draggableCursor\",\n      draggingCursor: \"draggingCursor\",\n      heading: \"heading\",\n      keyboardShortcuts: \"keyboardShortcuts\",\n      mapMaker: \"mapMaker\",\n      mapTypeControl: \"mapTypeControl\",\n      mapTypeId: \"mapTypeId\",\n      maxZoom: \"maxZoom\",\n      minZoom: \"minZoom\",\n      noClear: \"noClear\",\n      overviewMapControl: \"overviewMapControl\",\n      panControl: \"panControl\",\n      panControlOptions: \"panControlOptions\",\n      rotateControl: \"rotateControl\",\n      scaleControl: \"scaleControl\",\n      scrollwheel: \"scrollwheel\",\n      streetView: \"streetView\",\n      styles: \"styles\",\n      tilt: \"tilt\",\n      zoom: \"zoom\",\n      streetViewControl: \"streetViewControl\",\n      zoomControl: \"zoomControl\",\n      zoomControlOptions: \"zoomControlOptions\",\n      mapTypeControlOptions: \"mapTypeControlOptions\",\n      overviewMapControlOptions: \"overviewMapControlOptions\",\n      rotateControlOptions: \"rotateControlOptions\",\n      scaleControlOptions: \"scaleControlOptions\",\n      streetViewControlOptions: \"streetViewControlOptions\",\n      fullscreenControl: \"fullscreenControl\",\n      fullscreenControlOptions: \"fullscreenControlOptions\",\n      options: \"options\",\n      geoFallbackCenter: \"geoFallbackCenter\"\n    },\n    outputs: {\n      bounds_changed: \"bounds_changed\",\n      center_changed: \"center_changed\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      heading_changed: \"heading_changed\",\n      idle: \"idle\",\n      maptypeid_changed: \"maptypeid_changed\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      projection_changed: \"projection_changed\",\n      resize: \"resize\",\n      rightclick: \"rightclick\",\n      tilesloaded: \"tilesloaded\",\n      tile_changed: \"tile_changed\",\n      zoom_changed: \"zoom_changed\",\n      mapClick: \"mapClick\",\n      mapMouseover: \"mapMouseover\",\n      mapMouseout: \"mapMouseout\",\n      mapMousemove: \"mapMousemove\",\n      mapDrag: \"mapDrag\",\n      mapDragend: \"mapDragend\",\n      mapDragstart: \"mapDragstart\",\n      mapReady$: \"mapReady$\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"google-map\"]],\n    template: function NguiMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n    },\n    styles: [\"\\n    ngui-map {display: block; height: 300px;}\\n    .google-map {width: 100%; height: 100%}\\n  \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return NguiMapComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$1 = [];\nconst OUTPUTS$1 = [];\nlet BicyclingLayer = /*#__PURE__*/(() => {\n  class BicyclingLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'BicyclingLayer', INPUTS$1, OUTPUTS$1);\n    }\n\n  }\n\n  BicyclingLayer.ɵfac = function BicyclingLayer_Factory(t) {\n    return new (t || BicyclingLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  BicyclingLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BicyclingLayer,\n    selectors: [[\"bicycling-layer\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return BicyclingLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$2 = ['content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'];\nconst OUTPUTS$2 = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];\nlet InfoWindow = /*#__PURE__*/(() => {\n  class InfoWindow {\n    /**\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     * @param {?} nguiMapComponent\n     */\n    constructor(elementRef, nguiMap, nguiMapComponent) {\n      this.elementRef = elementRef;\n      this.nguiMap = nguiMap;\n      this.nguiMapComponent = nguiMapComponent;\n      this.initialized$ = new EventEmitter();\n      this.objectOptions = {};\n      this.inputChanges$ = new Subject();\n      this.elementRef.nativeElement.style.display = 'none';\n      OUTPUTS$2.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.nguiMapComponent.mapIdledOnce) {\n        // map is ready already\n        this.initialize();\n      } else {\n        this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS$2, this);\n      this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n      this.infoWindow['mapObjectName'] = 'InfoWindow'; // register infoWindow ids to NguiMap, so that it can be opened by id\n\n      if (this.elementRef.nativeElement.id) {\n        this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n      } else {\n        console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n      } // set google events listeners and emits to this outputs listeners\n\n\n      this.nguiMap.setObjectEvents(OUTPUTS$2, this, 'infoWindow'); // update object when input changes\n\n      this.inputChanges$.pipe(debounceTime(1000), tap(changes => this.nguiMap.updateGoogleObject(this.infoWindow, changes))).subscribe();\n      this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n      this.initialized$.emit(this.infoWindow);\n    }\n    /**\n     * @param {?} anchor\n     * @return {?}\n     */\n\n\n    open(anchor) {\n      // set content and open it\n      this.infoWindow.setContent(this.template.element.nativeElement);\n      this.infoWindow.open(this.nguiMapComponent.map, anchor);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    close() {\n      // check if infoWindow exists, and closes it\n      if (this.infoWindow) this.infoWindow.close();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.inputChanges$.complete();\n\n      if (this.infoWindow) {\n        this.nguiMap.clearObjectEvents(OUTPUTS$2, this, 'infoWindow');\n        delete this.infoWindow;\n      }\n    }\n\n  }\n\n  InfoWindow.ɵfac = function InfoWindow_Factory(t) {\n    return new (t || InfoWindow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  InfoWindow.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: InfoWindow,\n    selectors: [[\"info-window\"]],\n    viewQuery: function InfoWindow_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 5, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      content: \"content\",\n      disableAutoPan: \"disableAutoPan\",\n      maxWidth: \"maxWidth\",\n      pixelOffset: \"pixelOffset\",\n      position: \"position\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      closeclick: \"closeclick\",\n      content_changed: \"content_changed\",\n      domready: \"domready\",\n      position_changed: \"position_changed\",\n      zindex_changed: \"zindex_changed\",\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 0,\n    consts: [[\"template\", \"\"]],\n    template: function InfoWindow_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return InfoWindow;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$3 = ['position']; // to avoid DOM event conflicts map_*\n\nconst OUTPUTS$3 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged', 'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'];\n/**\n * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.\n * Otherwise throws a google is unknown error.\n * @param {?} htmlEl\n * @param {?} position\n * @return {?}\n */\n\nfunction getCustomMarkerOverlayView(htmlEl, position) {\n  class CustomMarkerOverlayView extends google.maps.OverlayView {\n    /**\n     * @param {?} htmlEl\n     * @param {?} position\n     */\n    constructor(htmlEl, position) {\n      super();\n      this.visible = true;\n\n      this.setPosition = position => {\n        this.htmlEl.style.visibility = 'hidden';\n\n        if (position.constructor.name === 'Array') {\n          this.position = new google.maps.LatLng(position[0], position[1]);\n        } else if (typeof position === 'string') {\n          let\n          /** @type {?} */\n          geocoder = new google.maps.Geocoder();\n          geocoder.geocode({\n            address: position\n          }, (results, status) => {\n            if (status === google.maps.GeocoderStatus.OK) {\n              this.setPosition(results[0].geometry.location);\n            } else {}\n          });\n        } else if (position && typeof position.lng === 'function') {\n          this.position = position;\n        }\n\n        if (this.getProjection() && typeof this.position.lng === 'function') {\n          let\n          /** @type {?} */\n          positionOnMap = () => {\n            let\n            /** @type {?} */\n            projection = this.getProjection();\n\n            if (!projection) {\n              return;\n            }\n\n            let\n            /** @type {?} */\n            posPixel = projection.fromLatLngToDivPixel(this.position);\n            let\n            /** @type {?} */\n            x = Math.round(posPixel.x - this.htmlEl.offsetWidth / 2);\n            let\n            /** @type {?} */\n            y = Math.round(posPixel.y - this.htmlEl.offsetHeight / 2);\n            this.htmlEl.style.left = x + 'px';\n            this.htmlEl.style.top = y + 'px';\n            this.htmlEl.style.visibility = 'visible';\n          };\n\n          if (this.htmlEl.offsetWidth && this.htmlEl.offsetHeight) {\n            positionOnMap();\n          } else {\n            setTimeout(() => positionOnMap());\n          }\n        }\n      };\n\n      this.htmlEl = htmlEl;\n      this.position = position;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onAdd() {\n      this.getPanes().overlayMouseTarget.appendChild(this.htmlEl); // required for correct display inside google maps container\n\n      this.htmlEl.style.position = 'absolute';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    draw() {\n      this.setPosition(this.position);\n      this.setZIndex(this.zIndex);\n      this.setVisible(this.visible);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onRemove() {//\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getPosition() {\n      return this.position;\n    }\n    /**\n     * @param {?} zIndex\n     * @return {?}\n     */\n\n\n    setZIndex(zIndex) {\n      zIndex && (this.zIndex = zIndex);\n      /* jshint ignore:line */\n\n      this.htmlEl.style.zIndex = this.zIndex;\n    }\n    /**\n     * @param {?} visible\n     * @return {?}\n     */\n\n\n    setVisible(visible) {\n      this.htmlEl.style.display = visible ? 'inline-block' : 'none';\n      this.visible = visible;\n    }\n\n  }\n\n  return new CustomMarkerOverlayView(htmlEl, position);\n}\n\nlet CustomMarker = /*#__PURE__*/(() => {\n  class CustomMarker {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     */\n    constructor(nguiMapComponent, elementRef, nguiMap) {\n      this.nguiMapComponent = nguiMapComponent;\n      this.elementRef = elementRef;\n      this.nguiMap = nguiMap;\n      this.initialized$ = new EventEmitter();\n      this.inputChanges$ = new Subject();\n      this.elementRef.nativeElement.style.display = 'none';\n      OUTPUTS$3.forEach(output => this[output] = new EventEmitter());\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.nguiMapComponent.mapIdledOnce) {\n        // map is ready already\n        this.initialize();\n      } else {\n        this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.inputChanges$.next(changes);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.inputChanges$.complete();\n      this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);\n\n      if (this.mapObject) {\n        this.nguiMap.clearObjectEvents(OUTPUTS$3, this, 'mapObject');\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      this.el = this.elementRef.nativeElement;\n      this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);\n      this.mapObject.setMap(this.nguiMapComponent.map); // set google events listeners and emits to this outputs listeners\n\n      this.nguiMap.setObjectEvents(OUTPUTS$3, this, 'mapObject'); // update object when input changes\n\n      this.inputChanges$.pipe(debounceTime(1000), tap(changes => this.nguiMap.updateGoogleObject(this.mapObject, changes))).subscribe();\n      this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);\n      this.initialized$.emit(this.mapObject);\n    }\n\n  }\n\n  CustomMarker.ɵfac = function CustomMarker_Factory(t) {\n    return new (t || CustomMarker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap));\n  };\n\n  CustomMarker.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CustomMarker,\n    selectors: [[\"custom-marker\"]],\n    inputs: {\n      position: \"position\"\n    },\n    outputs: {\n      animationChanged: \"animationChanged\",\n      click: \"click\",\n      clickableChanged: \"clickableChanged\",\n      cursorChanged: \"cursorChanged\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      draggableChanged: \"draggableChanged\",\n      dragstart: \"dragstart\",\n      flatChanged: \"flatChanged\",\n      iconChanged: \"iconChanged\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      positionChanged: \"positionChanged\",\n      rightclick: \"rightclick\",\n      shapeChanged: \"shapeChanged\",\n      titleChanged: \"titleChanged\",\n      visibleChanged: \"visibleChanged\",\n      zindexChanged: \"zindexChanged\",\n      map_click: \"map_click\",\n      map_mouseover: \"map_mouseover\",\n      map_mouseout: \"map_mouseout\",\n      map_mouseup: \"map_mouseup\",\n      map_mousedown: \"map_mousedown\",\n      map_drag: \"map_drag\",\n      map_dragend: \"map_dragend\",\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CustomMarker_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return CustomMarker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$4 = ['center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options', 'geoFallbackCenter'];\nconst OUTPUTS$4 = ['centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick'];\nlet Circle = /*#__PURE__*/(() => {\n  class Circle extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'Circle', INPUTS$4, OUTPUTS$4);\n      this.nguiMapComp = nguiMapComp;\n      this.objectOptions =\n      /** @type {?} */\n      {};\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      super.initialize();\n      this.setCenter();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setCenter() {\n      if (!this['center']) {\n        this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(center => {\n          let\n          /** @type {?} */\n          latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n          this.mapObject.setCenter(latLng);\n        }, error => {\n          console.error('ngui-map, error in finding the current position');\n          this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        }));\n      } else if (typeof this['center'] === 'string') {\n        this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n          address: this['center']\n        }).subscribe(results => {\n          this.mapObject.setCenter(results[0].geometry.location);\n        }, error => {\n          console.error('ngui-map, error in finding location from', this['center']);\n          this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        }));\n      }\n    }\n\n  }\n\n  Circle.ɵfac = function Circle_Factory(t) {\n    return new (t || Circle)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Circle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Circle,\n    selectors: [[\"circle\"], [\"map-circle\"]],\n    inputs: {\n      center: \"center\",\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      map: \"map\",\n      radius: \"radius\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\",\n      geoFallbackCenter: \"geoFallbackCenter\"\n    },\n    outputs: {\n      centerChanged: \"centerChanged\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      radiusChanged: \"radiusChanged\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Circle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$5 = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nconst OUTPUTS$5 = ['addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'];\nlet DataLayer = /*#__PURE__*/(() => {\n  class DataLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     */\n    constructor(nguiMapComponent) {\n      super(nguiMapComponent, 'Data', INPUTS$5, OUTPUTS$5);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      if (this['geoJson']) {\n        // addGeoJson from an object\n        this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n      } else if (this['geoJsonUrl']) {\n        // loadGeoJson from a URL\n        this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n      } else {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        this.nguiMapComponent.map.data.add(this.objectOptions);\n      } // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n\n\n      this.mapObject = this.nguiMapComponent.map.data; // set google events listeners and emits to this outputs listeners\n\n      this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n      this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n      this.initialized$.emit(this.mapObject);\n    }\n\n  }\n\n  DataLayer.ɵfac = function DataLayer_Factory(t) {\n    return new (t || DataLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  DataLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DataLayer,\n    selectors: [[\"data-layer\"]],\n    inputs: {\n      controlPosition: \"controlPosition\",\n      controls: \"controls\",\n      drawingMode: \"drawingMode\",\n      featureFactory: \"featureFactory\",\n      style: \"style\",\n      geoJson: \"geoJson\",\n      geoJsonUrl: \"geoJsonUrl\"\n    },\n    outputs: {\n      addfeature: \"addfeature\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      removefeature: \"removefeature\",\n      removeproperty: \"removeproperty\",\n      rightclick: \"rightclick\",\n      setgeometry: \"setgeometry\",\n      setproperty: \"setproperty\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return DataLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$6 = ['directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions', 'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer', 'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'];\nconst OUTPUTS$6 = ['directions_changed'];\nlet DirectionsRenderer = /*#__PURE__*/(() => {\n  class DirectionsRenderer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} geolocation\n     */\n    constructor(nguiMapComponent, geolocation) {\n      super(nguiMapComponent, 'DirectionsRenderer', INPUTS$6, OUTPUTS$6);\n      this.geolocation = geolocation;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n\n      if (typeof this.objectOptions['panel'] === 'string') {\n        // find a Node for panel\n        this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n      }\n\n      this.directionsService = new google.maps.DirectionsService();\n      this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n      this.directionsRenderer.setMap(this.nguiMapComponent.map); // set google events listeners and emidirectionsRenderer to this outputs listeners\n\n      this.showDirections(this.directionsRequest);\n      this.nguiMap.setObjectEvents(this.outputs, this, 'directionsRenderer');\n      this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n      this.initialized$.emit(this.directionsRenderer);\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      let\n      /** @type {?} */\n      newOptions = {};\n\n      for (let\n      /** @type {?} */\n      key in changes) {\n        if (this.inputs.indexOf(key) !== -1) {\n          newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n        }\n      }\n\n      if (changes['directionsRequest'] && this.directionsRenderer) {\n        this.directionsService && this.showDirections(this.directionsRequest);\n      }\n    }\n    /**\n     * @param {?} directionsRequest\n     * @return {?}\n     */\n\n\n    showDirections(directionsRequest) {\n      this.directionsService.route(directionsRequest, (response, status) => {\n        // in some-case the callback is called during destroy component,\n        // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n        if (!this.directionsRenderer) {\n          return;\n        }\n\n        if (status === google.maps.DirectionsStatus.OK) {\n          this.directionsRenderer.setDirections(response);\n        } else {\n          console.error('Directions request failed due to ' + status);\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n    }\n\n  }\n\n  DirectionsRenderer.ɵfac = function DirectionsRenderer_Factory(t) {\n    return new (t || DirectionsRenderer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation));\n  };\n\n  DirectionsRenderer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DirectionsRenderer,\n    selectors: [[\"directions-renderer\"]],\n    inputs: {\n      directions: \"directions\",\n      draggable: \"draggable\",\n      hideRouteList: \"hideRouteList\",\n      infoWindow: \"infoWindow\",\n      panel: \"panel\",\n      markerOptions: \"markerOptions\",\n      polylineOptions: \"polylineOptions\",\n      preserveViewport: \"preserveViewport\",\n      routeIndex: \"routeIndex\",\n      suppressBicyclingLayer: \"suppressBicyclingLayer\",\n      suppressInfoWindows: \"suppressInfoWindows\",\n      suppressMarkers: \"suppressMarkers\",\n      suppressPolylines: \"suppressPolylines\",\n      directionsRequest: [\"directions-request\", \"directionsRequest\"]\n    },\n    outputs: {\n      directions_changed: \"directions_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return DirectionsRenderer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$7 = ['options', 'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode', 'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'];\nconst OUTPUTS$7 = ['circlecomplete', 'markercomplete', 'overlaycomplete', 'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'];\nlet DrawingManager = /*#__PURE__*/(() => {\n  class DrawingManager extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'DrawingManager', INPUTS$7, OUTPUTS$7);\n      this.libraryName = 'drawing';\n    }\n\n  }\n\n  DrawingManager.ɵfac = function DrawingManager_Factory(t) {\n    return new (t || DrawingManager)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  DrawingManager.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DrawingManager,\n    selectors: [[\"drawing-manager\"]],\n    inputs: {\n      options: \"options\",\n      circleOptions: \"circleOptions\",\n      drawingControl: \"drawingControl\",\n      drawingControlOptions: \"drawingControlOptions\",\n      drawingMode: \"drawingMode\",\n      map: \"map\",\n      markerOptions: \"markerOptions\",\n      polygonOptions: \"polygonOptions\",\n      polylineOptions: \"polylineOptions\",\n      rectangleOptions: \"rectangleOptions\"\n    },\n    outputs: {\n      circlecomplete: \"circlecomplete\",\n      markercomplete: \"markercomplete\",\n      overlaycomplete: \"overlaycomplete\",\n      polygoncomplete: \"polygoncomplete\",\n      polylinecomplete: \"polylinecomplete\",\n      rectanglecomplete: \"rectanglecomplete\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return DrawingManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$8 = ['url', 'bounds', 'clickable', 'opacity'];\nconst OUTPUTS$8 = ['click', 'dblclick'];\nlet GroundOverlay = /*#__PURE__*/(() => {\n  class GroundOverlay extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'GroundOverlay', INPUTS$8, OUTPUTS$8);\n      this.objectOptions =\n      /** @type {?} */\n      {};\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      // url, bounds are not the options of GroundOverlay\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this); // noinspection TypeScriptUnresolvedFunction\n\n      this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n      this.mapObject.setMap(this.nguiMapComponent.map);\n      this.mapObject['mapObjectName'] = this.mapObjectName; // set google events listeners and emits to this outputs listeners\n\n      this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n      this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n      this.initialized$.emit(this.mapObject);\n    }\n\n  }\n\n  GroundOverlay.ɵfac = function GroundOverlay_Factory(t) {\n    return new (t || GroundOverlay)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  GroundOverlay.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: GroundOverlay,\n    selectors: [[\"ground-overlay\"]],\n    inputs: {\n      url: \"url\",\n      bounds: \"bounds\",\n      clickable: \"clickable\",\n      opacity: \"opacity\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return GroundOverlay;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$9 = ['data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options'];\nconst OUTPUTS$9 = [];\nlet HeatmapLayer = /*#__PURE__*/(() => {\n  class HeatmapLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'HeatmapLayer', INPUTS$9, OUTPUTS$9);\n      this.libraryName = 'visualization';\n    }\n\n  }\n\n  HeatmapLayer.ɵfac = function HeatmapLayer_Factory(t) {\n    return new (t || HeatmapLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  HeatmapLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HeatmapLayer,\n    selectors: [[\"heatmap-layer\"]],\n    inputs: {\n      data: \"data\",\n      dissipating: \"dissipating\",\n      gradient: \"gradient\",\n      maxIntensity: \"maxIntensity\",\n      opacity: \"opacity\",\n      radius: \"radius\",\n      options: \"options\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return HeatmapLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$10 = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options'];\nconst OUTPUTS$10 = ['click', 'defaultviewport_changed', 'status_changed'];\nlet KmlLayer = /*#__PURE__*/(() => {\n  class KmlLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'KmlLayer', INPUTS$10, OUTPUTS$10);\n    }\n\n  }\n\n  KmlLayer.ɵfac = function KmlLayer_Factory(t) {\n    return new (t || KmlLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  KmlLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: KmlLayer,\n    selectors: [[\"kml-layer\"]],\n    inputs: {\n      clickable: \"clickable\",\n      preserveViewport: \"preserveViewport\",\n      screenOverlays: \"screenOverlays\",\n      suppressInfoWindows: \"suppressInfoWindows\",\n      url: \"url\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      defaultviewport_changed: \"defaultviewport_changed\",\n      status_changed: \"status_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return KmlLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$11 = ['anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity', 'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options', 'geoFallbackPosition'];\nconst OUTPUTS$11 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'];\nlet Marker = /*#__PURE__*/(() => {\n  class Marker extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'Marker', INPUTS$11, OUTPUTS$11);\n      this.nguiMapComp = nguiMapComp;\n      this.objectOptions =\n      /** @type {?} */\n      {};\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.nguiMapComponent.mapIdledOnce) {\n        // map is ready already\n        this.initialize();\n      } else {\n        this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      super.initialize();\n      this.setPosition();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setPosition() {\n      if (!this['position']) {\n        this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(position => {\n          let\n          /** @type {?} */\n          latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n          this.mapObject.setPosition(latLng);\n        }, error => {\n          console.error('ngui-map, error finding the current location');\n          this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n        }));\n      } else if (typeof this['position'] === 'string') {\n        this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n          address: this['position']\n        }).subscribe(results => {\n          this.mapObject.setPosition(results[0].geometry.location);\n        }, error => {\n          console.error('ngui-map, error finding the location from', this['position']);\n          this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n        }));\n      }\n    }\n\n  }\n\n  Marker.ɵfac = function Marker_Factory(t) {\n    return new (t || Marker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Marker.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Marker,\n    selectors: [[\"marker\"]],\n    inputs: {\n      anchorPoint: \"anchorPoint\",\n      animation: \"animation\",\n      clickable: \"clickable\",\n      cursor: \"cursor\",\n      draggable: \"draggable\",\n      icon: \"icon\",\n      label: \"label\",\n      opacity: \"opacity\",\n      optimized: \"optimized\",\n      place: \"place\",\n      position: \"position\",\n      shape: \"shape\",\n      title: \"title\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\",\n      geoFallbackPosition: \"geoFallbackPosition\"\n    },\n    outputs: {\n      animationChanged: \"animationChanged\",\n      click: \"click\",\n      clickableChanged: \"clickableChanged\",\n      cursorChanged: \"cursorChanged\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      draggableChanged: \"draggableChanged\",\n      dragstart: \"dragstart\",\n      flatChanged: \"flatChanged\",\n      iconChanged: \"iconChanged\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      positionChanged: \"positionChanged\",\n      rightclick: \"rightclick\",\n      shapeChanged: \"shapeChanged\",\n      titleChanged: \"titleChanged\",\n      visibleChanged: \"visibleChanged\",\n      zindexChanged: \"zindexChanged\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Marker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nlet PlacesAutoComplete = /*#__PURE__*/(() => {\n  class PlacesAutoComplete {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} apiLoader\n     */\n    constructor(optionBuilder, elementRef, apiLoader) {\n      this.optionBuilder = optionBuilder;\n      this.elementRef = elementRef;\n      this.apiLoader = apiLoader;\n      this.place_changed = new EventEmitter();\n      this.initialized$ = new EventEmitter(); // only called when map is ready\n\n      this.initialize = () => {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], this);\n\n        if (!google.maps.places) {\n          throw missingLibraryError('PlacesAutoComplete', 'places');\n        }\n\n        this.autocomplete = new google.maps.places.Autocomplete(this.elementRef.nativeElement, this.objectOptions);\n        this.autocomplete.addListener('place_changed', place => {\n          this.place_changed.emit(this.autocomplete.getPlace());\n        });\n        this.initialized$.emit(this.autocomplete);\n      };\n\n      apiLoader.load();\n      apiLoader.api$.pipe(first()).subscribe(() => this.initialize());\n    }\n\n  }\n\n  PlacesAutoComplete.ɵfac = function PlacesAutoComplete_Factory(t) {\n    return new (t || PlacesAutoComplete)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader));\n  };\n\n  PlacesAutoComplete.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: PlacesAutoComplete,\n    selectors: [[\"\", \"places-auto-complete\", \"\"]],\n    inputs: {\n      bounds: \"bounds\",\n      componentRestrictions: \"componentRestrictions\",\n      types: \"types\"\n    },\n    outputs: {\n      place_changed: \"place_changed\",\n      initialized$: \"initialized$\"\n    }\n  });\n  /** @nocollapse */\n\n  return PlacesAutoComplete;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$12 = ['clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options'];\nconst OUTPUTS$12 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\nlet Polygon = /*#__PURE__*/(() => {\n  class Polygon extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'Polygon', INPUTS$12, OUTPUTS$12);\n    }\n\n  }\n\n  Polygon.ɵfac = function Polygon_Factory(t) {\n    return new (t || Polygon)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Polygon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Polygon,\n    selectors: [[\"polygon\"], [\"map-polygon\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      geodesic: \"geodesic\",\n      paths: \"paths\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Polygon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$13 = ['clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'];\nconst OUTPUTS$13 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\nlet Polyline = /*#__PURE__*/(() => {\n  class Polyline extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'Polyline', INPUTS$13, OUTPUTS$13);\n    }\n\n  }\n\n  Polyline.ɵfac = function Polyline_Factory(t) {\n    return new (t || Polyline)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Polyline.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Polyline,\n    selectors: [[\"polyline\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      geodesic: \"geodesic\",\n      icons: \"icons\",\n      path: \"path\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Polyline;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$14 = ['selector', 'options', 'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom', 'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl', 'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano', 'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'];\nconst OUTPUTS$14 = ['closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed', 'visible_changed', 'zoom_changed'];\nlet StreetViewPanorama = /*#__PURE__*/(() => {\n  class StreetViewPanorama extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'StreetViewPanorama', INPUTS$14, OUTPUTS$14);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    initialize() {\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n      let\n      /** @type {?} */\n      element;\n\n      if (this.objectOptions.selector) {\n        // noinspection TypeScriptValidateTypes\n        element = document.querySelector(this['selector']);\n        delete this.objectOptions.selector;\n      } else {\n        element = this.nguiMapComponent.el;\n      } // will be set after geocoded\n\n\n      typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n      this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n      this.mapObject['mapObjectName'] = this.mapObjectName;\n      this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n      this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n      this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n      this.initialized$.emit(this.mapObject);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.nguiMapComponent.el) {\n        this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n      }\n    }\n\n  }\n\n  StreetViewPanorama.ɵfac = function StreetViewPanorama_Factory(t) {\n    return new (t || StreetViewPanorama)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  StreetViewPanorama.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: StreetViewPanorama,\n    selectors: [[\"street-view-panorama\"]],\n    inputs: {\n      selector: \"selector\",\n      options: \"options\",\n      addressControl: \"addressControl\",\n      addressControlOptions: \"addressControlOptions\",\n      clickToGo: \"clickToGo\",\n      disableDefaultUI: \"disableDefaultUI\",\n      disableDoubleClickZoom: \"disableDoubleClickZoom\",\n      enableCloseButton: \"enableCloseButton\",\n      fullscreenControl: \"fullscreenControl\",\n      fullscreenControlOptions: \"fullscreenControlOptions\",\n      imageDateControl: \"imageDateControl\",\n      linksControl: \"linksControl\",\n      motionTracking: \"motionTracking\",\n      motionTrackingControl: \"motionTrackingControl\",\n      panControl: \"panControl\",\n      panControlOptions: \"panControlOptions\",\n      pano: \"pano\",\n      position: \"position\",\n      pov: \"pov\",\n      scrollwheel: \"scrollwheel\",\n      showRoadLabels: \"showRoadLabels\",\n      visible: \"visible\",\n      zoomControl: \"zoomControl\",\n      zoomControlOptions: \"zoomControlOptions\"\n    },\n    outputs: {\n      closeclick: \"closeclick\",\n      pano_changed: \"pano_changed\",\n      position_changed: \"position_changed\",\n      pov_changed: \"pov_changed\",\n      resize: \"resize\",\n      status_changed: \"status_changed\",\n      visible_changed: \"visible_changed\",\n      zoom_changed: \"zoom_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return StreetViewPanorama;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$15 = ['autoRefresh', 'options'];\nconst OUTPUTS$15 = [];\nlet TrafficLayer = /*#__PURE__*/(() => {\n  class TrafficLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'TrafficLayer', INPUTS$15, OUTPUTS$15);\n    }\n\n  }\n\n  TrafficLayer.ɵfac = function TrafficLayer_Factory(t) {\n    return new (t || TrafficLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  TrafficLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TrafficLayer,\n    selectors: [[\"traffic-layer\"]],\n    inputs: {\n      autoRefresh: \"autoRefresh\",\n      options: \"options\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return TrafficLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst INPUTS$16 = [];\nconst OUTPUTS$16 = [];\nlet TransitLayer = /*#__PURE__*/(() => {\n  class TransitLayer extends BaseMapDirective {\n    /**\n     * @param {?} nguiMapComp\n     */\n    constructor(nguiMapComp) {\n      super(nguiMapComp, 'TransitLayer', INPUTS$16, OUTPUTS$16);\n    }\n\n  }\n\n  TransitLayer.ɵfac = function TransitLayer_Factory(t) {\n    return new (t || TransitLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  TransitLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TransitLayer,\n    selectors: [[\"transit-layer\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return TransitLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nconst COMPONENTS_DIRECTIVES = [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\nlet NguiMapModule = /*#__PURE__*/(() => {\n  class NguiMapModule {\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n      return {\n        ngModule: NguiMapModule,\n        providers: [{\n          provide: NG_MAP_CONFIG_TOKEN,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  NguiMapModule.ɵfac = function NguiMapModule_Factory(t) {\n    return new (t || NguiMapModule)();\n  };\n\n  NguiMapModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NguiMapModule\n  });\n  NguiMapModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [GeoCoder, NavigatorGeolocation, NguiMap, OptionBuilder, {\n      provide: NgMapApiLoader,\n      useClass: NgMapAsyncCallbackApiLoader\n    }],\n    imports: [CommonModule]\n  });\n  return NguiMapModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NguiMapModule, {\n    declarations: function () {\n      return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BicyclingLayer, NavigatorGeolocation, OptionBuilder, NG_MAP_CONFIG_TOKEN, NgMapApiLoader, NgMapAsyncApiLoader, NgMapAsyncCallbackApiLoader, NguiMapComponent, InfoWindow, CustomMarker, Circle, DataLayer, DirectionsRenderer, DrawingManager, GeoCoder, GroundOverlay, HeatmapLayer, KmlLayer, Marker, NguiMap, PlacesAutoComplete, Polygon, Polyline, StreetViewPanorama, TrafficLayer, TransitLayer, NguiMapModule, BaseMapDirective as ɵa }; //# sourceMappingURL=ngui-map.js.map","map":null,"metadata":{},"sourceType":"module"}